import type { ModuleCoverage, OverallCoverage } from '../coverage';
import type { HistoryComparison, HistoryEntry } from '../history/index';
import { formatDelta, getTrendIndicator } from '../history/index';
import { generateCoverageTrendGraph, type TrendData } from './graphs';

/**
 * HTML comment identifier for finding and updating PR comments
 * Exported for use in GitHub PR comment integration
 */
export const COMMENT_IDENTIFIER = '<!-- kover-coverage-report -->';

/**
 * Repository URL for action link in report footer
 */
const REPO_URL = 'https://github.com/yshrsmz/kover-report-action';

/**
 * Generate a Markdown report for PR comments
 * Includes overall coverage, per-module breakdown, and status indicators
 * @param overall Overall coverage data with per-module breakdown
 * @param title Report title (displayed as heading)
 * @param comparison Optional history comparison for trend indicators
 * @param history Optional history entries for trend graphs
 * @returns Markdown-formatted report with HTML comment identifier
 */
export function generateMarkdownReport(
  overall: OverallCoverage,
  title: string,
  comparison?: HistoryComparison,
  history?: HistoryEntry[]
): string {
  const lines: string[] = [];

  // HTML comment identifier for finding and updating the comment
  lines.push(COMMENT_IDENTIFIER);
  lines.push('');

  // Title with emoji
  lines.push(`## ðŸ“Š ${title}`);
  lines.push('');

  // Overall coverage summary with trend indicator if available
  const formattedOverall = formatPercentage(overall.percentage);
  if (comparison) {
    const trendIndicator = getTrendIndicator(comparison.overallDelta);
    const delta = formatDelta(comparison.overallDelta);
    lines.push(`**Overall Coverage: ${formattedOverall}** ${trendIndicator} ${delta}`);
  } else {
    lines.push(`**Overall Coverage: ${formattedOverall}**`);
  }
  lines.push('');

  // Coverage trend graph (if history is available and has multiple entries)
  if (history && history.length > 1) {
    const trendData = convertHistoryToTrendData(history);
    if (trendData.length > 1) {
      lines.push('### Coverage Trend');
      lines.push('');
      lines.push('```');
      lines.push(generateCoverageTrendGraph(trendData, 'Overall Coverage History'));
      lines.push('```');
      lines.push('');
    }
  }

  // Module coverage table
  lines.push('### Module Coverage');
  lines.push('');

  // Table header - add "Change" column if comparison is available
  if (comparison) {
    lines.push('| Module | Coverage | Threshold | Change | Status |');
    lines.push('|--------|----------|-----------|--------|--------|');
  } else {
    lines.push('| Module | Coverage | Threshold | Status |');
    lines.push('|--------|----------|-----------|--------|');
  }

  // Sort modules alphabetically for consistent output
  const sortedModules = [...overall.modules].sort((a, b) => a.module.localeCompare(b.module));

  for (const module of sortedModules) {
    const coverageStr = formatCoverage(module);
    const thresholdStr = `${module.threshold}%`;
    const statusStr = formatStatus(module);

    if (comparison) {
      const changeStr = formatChange(module.module, comparison);
      lines.push(
        `| ${module.module} | ${coverageStr} | ${thresholdStr} | ${changeStr} | ${statusStr} |`
      );
    } else {
      lines.push(`| ${module.module} | ${coverageStr} | ${thresholdStr} | ${statusStr} |`);
    }
  }

  // Legend explaining status indicators
  lines.push('');
  lines.push('### Legend');
  lines.push('- âœ… Coverage meets threshold');
  lines.push('- âŒ Coverage below threshold');
  lines.push('- âš ï¸ No coverage report found');

  // Footer with action attribution
  lines.push('');
  lines.push('---');
  lines.push('');
  lines.push(`_Generated by [kover-report-action](${REPO_URL})_`);

  return lines.join('\n');
}

/**
 * Format coverage percentage or N/A for null coverage
 * @param module Module coverage data
 * @returns Formatted coverage string (e.g., "85.5%" or "N/A")
 */
function formatCoverage(module: ModuleCoverage): string {
  if (module.coverage === null) {
    return 'N/A';
  }
  return formatPercentage(module.coverage.percentage);
}

/**
 * Format percentage to 1 decimal place
 * @param percentage Raw percentage value (0-100)
 * @returns Formatted percentage string (e.g., "85.5%")
 */
function formatPercentage(percentage: number): string {
  return `${(Math.round(percentage * 10) / 10).toFixed(1)}%`;
}

/**
 * Format status indicator based on module status
 * Returns emoji indicator: âœ… for pass, âŒ for fail, âš ï¸ for missing coverage
 * @param module Module coverage data
 * @returns Status emoji indicator
 */
function formatStatus(module: ModuleCoverage): string {
  if (module.coverage === null) {
    return 'âš ï¸';
  }
  return module.passed ? 'âœ…' : 'âŒ';
}

/**
 * Format change indicator for a module based on history comparison
 * Shows trend indicator and delta, or indicator for new modules
 * @param moduleName Name of the module
 * @param comparison History comparison data
 * @returns Formatted change string (e.g., "â†‘ +1.5%" or "new")
 */
function formatChange(moduleName: string, comparison: HistoryComparison): string {
  const delta = comparison.moduleDelta[moduleName];

  // Module exists in current but not in baseline (new module)
  if (delta === null || delta === undefined) {
    return 'new';
  }

  const trendIndicator = getTrendIndicator(delta);
  const deltaStr = formatDelta(delta);
  return `${trendIndicator} ${deltaStr}`;
}

/**
 * Convert history entries to TrendData format for graph generation
 * @param history Array of history entries
 * @returns Array of TrendData with labels and values
 */
function convertHistoryToTrendData(history: HistoryEntry[]): TrendData[] {
  return history
    .map((entry) => ({
      label: formatHistoryLabel(entry),
      value: entry.overall.percentage,
    }))
    .reverse(); // Reverse to show oldest to newest (left to right)
}

/**
 * Format a history entry as a label for trend graphs
 * Uses short commit SHA or date
 * @param entry History entry
 * @returns Formatted label string
 */
function formatHistoryLabel(entry: HistoryEntry): string {
  // Try to use short commit SHA (first 7 chars, or less if shorter)
  if (entry.commit && entry.commit !== 'unknown') {
    return entry.commit.substring(0, Math.min(7, entry.commit.length));
  }

  // Fallback to date
  const date = new Date(entry.timestamp);
  if (Number.isNaN(date.getTime())) {
    return 'N/A';
  }

  try {
    return date.toISOString().substring(5, 10); // MM-DD format
  } catch {
    return 'N/A';
  }
}
